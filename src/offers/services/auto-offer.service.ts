import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Offer } from '../entities/offer.entity';
import { Produce } from '../../produce/entities/produce.entity';
import { ProduceService } from '../../produce/produce.service';
import { BuyersService } from '../../buyers/buyers.service';
import { OfferStatus } from '../enums/offer-status.enum';

@Injectable()
export class AutoOfferService {
  constructor(
    @InjectRepository(Offer)
    private readonly offerRepository: Repository<Offer>,
    private readonly produceService: ProduceService,
    private readonly buyersService: BuyersService
  ) {}

  async generateOffersForProduce(produce: Produce) {
    if (!produce.location) {
      return [];
    }

    const nearbyBuyers = await this.buyersService.findNearby(
      produce.location.lat,
      produce.location.lng,
      100
    );

    const offers: Offer[] = [];

    for (const buyer of nearbyBuyers) {
      const offer = new Offer();
      Object.assign(offer, {
        buyerId: buyer.id,
        produceId: produce.id,
        pricePerUnit: produce.pricePerUnit,
        quantity: produce.quantity,
        status: OfferStatus.PENDING,
        metadata: {
          qualityGrade: produce.qualityGrade,
          autoGeneratedAt: new Date(),
          priceHistory: [],
          lastPriceUpdate: {
            oldPrice: 0,
            newPrice: produce.pricePerUnit,
            timestamp: new Date()
          }
        },
        createdAt: new Date(),
        updatedAt: new Date()
      });

      offers.push(await this.offerRepository.save(offer));
    }

    return offers;
  }

  async generateOffersForBuyer(buyer: any) {
    if (!buyer.location) {
      return [];
    }

    const matchingProduce = await this.produceService.findNearby({
      latitude: buyer.location.lat,
      longitude: buyer.location.lng,
      radiusInKm: 100
    });

    const offers: Offer[] = [];

    for (const produce of matchingProduce) {
      const offer = new Offer();
      Object.assign(offer, {
        buyerId: buyer.id,
        produceId: produce.id,
        pricePerUnit: produce.pricePerUnit,
        quantity: produce.quantity,
        status: OfferStatus.PENDING,
        metadata: {
          qualityGrade: produce.qualityGrade,
          autoGeneratedAt: new Date(),
          priceHistory: [],
          lastPriceUpdate: {
            oldPrice: 0,
            newPrice: produce.pricePerUnit,
            timestamp: new Date()
          }
        },
        createdAt: new Date(),
        updatedAt: new Date()
      });

      offers.push(await this.offerRepository.save(offer));
    }

    return offers;
  }
} 
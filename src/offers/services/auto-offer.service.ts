import { Injectable } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Offer } from '../entities/offer.entity';
import { BuyersService } from '../../buyers/buyers.service';
import { ProduceService } from '../../produce/produce.service';
import { NotificationsService } from '../../notifications/notifications.service';
import { NotificationType } from '../../notifications/entities/notification.entity';
import { OfferStatus } from '../enums/offer-status.enum';

@Injectable()
export class AutoOfferService {
  constructor(
    @InjectRepository(Offer)
    private readonly offerRepository: Repository<Offer>,
    private readonly buyersService: BuyersService,
    private readonly produceService: ProduceService,
    private readonly notificationsService: NotificationsService,
  ) {}

  @OnEvent('quality.grade.finalized')
  async handleQualityGradeFinalized(payload: { produceId: string; grade: string }) {
    const { produceId, grade } = payload;
    const produce = await this.produceService.findOne(produceId);
    if (!produce) return;

    // Get all active buyers within 100km
    const nearbyBuyers = await this.buyersService.findNearby(produce.lat, produce.lng, 100);
    const generatedOffers: Array<{ buyer: any; price: number; offer: Offer }> = [];

    // Generate offers for each nearby buyer with matching price
    for (const buyer of nearbyBuyers) {
      const price = await this.buyersService.getBuyerPriceByGrade(
        buyer.id,
        grade,
        new Date()
      );

      if (price) {
        // Create auto-generated offer
        const offer = await this.offerRepository.save({
          buyerId: buyer.id,
          produceId,
          pricePerUnit: price.pricePerUnit,
          quantity: produce.quantity,
          status: OfferStatus.AUTO_GENERATED,
          isAutoGenerated: true,
        });

        generatedOffers.push({
          buyer,
          price: price.pricePerUnit,
          offer,
        });
      }
    }

    if (generatedOffers.length > 0) {
      // Create a summary of all offers
      const offerSummary = generatedOffers.map(({ buyer, price }) => 
        `${buyer.name}: ${price} per ${produce.unit}`
      ).join('\n');

      // Send a single consolidated notification to the farmer
      await this.notificationsService.create(
        produce.farmerId,
        NotificationType.OFFER_CREATED,
        'Multiple Auto-Generated Offers Received',
        `Your ${produce.name} (Grade: ${grade}) has received ${generatedOffers.length} offers from buyers in your area:\n\n${offerSummary}`,
        {
          produceId: produce.id,
          offerIds: generatedOffers.map(go => go.offer.id),
          totalOffers: generatedOffers.length,
          averagePrice: generatedOffers.reduce((sum, go) => sum + go.price, 0) / generatedOffers.length,
        }
      );
    }
  }

  @OnEvent('buyer.price.created')
  async handleBuyerPriceCreated(payload: { buyerId: string; price: any }) {
    const { buyerId, price } = payload;
    const buyer = await this.buyersService.findOne(buyerId);
    if (!buyer) return;
    
    // Find all produce listings with matching grade within 100km
    const matchingProduce = await this.produceService.findByGradeAndLocation(
      price.qualityGrade,
      buyer.lat,
      buyer.lng,
      100
    );
    
    const generatedOffers: Array<{ produce: any; offer: Offer }> = [];

    for (const produce of matchingProduce) {
      // Check if buyer already has an active offer for this produce
      const existingOffer = await this.offerRepository.findOne({
        where: {
          buyerId,
          produceId: produce.id,
          status: OfferStatus.AUTO_GENERATED,
        },
      });

      if (!existingOffer) {
        // Create new auto-generated offer
        const offer = await this.offerRepository.save({
          buyerId,
          produceId: produce.id,
          pricePerUnit: price.pricePerUnit,
          quantity: produce.quantity,
          status: OfferStatus.AUTO_GENERATED,
          isAutoGenerated: true,
        });

        generatedOffers.push({
          produce,
          offer,
        });

        // Send individual notification to each farmer
        await this.notificationsService.create(
          produce.farmerId,
          NotificationType.OFFER_CREATED,
          'New Auto-Generated Offer',
          `A new offer has been automatically generated for your ${produce.name} based on your quality grade. Price per unit: ${price.pricePerUnit}`,
          {
            offerId: offer.id,
            produceId: produce.id,
            buyerId,
          }
        );
      }
    }
  }
} 
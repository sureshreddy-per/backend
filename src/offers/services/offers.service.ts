import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Offer } from '../entities/offer.entity';
import { CreateOfferDto } from '../dto/create-offer.dto';
import { UpdateOfferDto } from '../dto/update-offer.dto';
import { OverrideAutoOfferDto } from '../dto/override-auto-offer.dto';
import { OfferStatus } from '../enums/offer-status.enum';
import { AutoOfferManagerService } from './auto-offer-manager.service';
import { NotificationsService } from '../../notifications/notifications.service';
import { NotificationType } from '../../notifications/entities/notification.entity';

@Injectable()
export class OffersService {
  constructor(
    @InjectRepository(Offer)
    private readonly offerRepository: Repository<Offer>,
    private readonly autoOfferManager: AutoOfferManagerService,
    private readonly notificationsService: NotificationsService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  async create(createOfferDto: CreateOfferDto): Promise<Offer> {
    const offer = this.offerRepository.create(createOfferDto);
    const savedOffer = await this.offerRepository.save(offer);

    this.eventEmitter.emit('offer.created', {
      offerId: savedOffer.id,
      produceId: savedOffer.produceId,
      buyerId: savedOffer.buyerId,
    });

    return savedOffer;
  }

  async findAutoGenerated(produceId?: string, buyerId?: string): Promise<Offer[]> {
    const query = this.offerRepository
      .createQueryBuilder('offer')
      .where('offer.isAutoGenerated = :isAuto', { isAuto: true })
      .andWhere('offer.status = :status', { status: OfferStatus.AUTO_GENERATED });

    if (produceId) {
      query.andWhere('offer.produceId = :produceId', { produceId });
    }

    if (buyerId) {
      query.andWhere('offer.buyerId = :buyerId', { buyerId });
    }

    return query.getMany();
  }

  async overrideAutoOffer(id: string, overrideDto: OverrideAutoOfferDto): Promise<Offer> {
    const offer = await this.offerRepository.findOne({
      where: { id },
      relations: ['produce'],
    });

    if (!offer) {
      throw new NotFoundException(`Offer with ID ${id} not found`);
    }

    if (!offer.isAutoGenerated) {
      throw new BadRequestException('Only auto-generated offers can be overridden');
    }

    if (offer.status !== OfferStatus.AUTO_GENERATED) {
      throw new BadRequestException('Only active auto-generated offers can be overridden');
    }

    // Apply override
    if (overrideDto.pricePerUnit) {
      offer.pricePerUnit = overrideDto.pricePerUnit;
    }
    if (overrideDto.quantity) {
      offer.quantity = overrideDto.quantity;
    }
    if (overrideDto.message) {
      offer.message = overrideDto.message;
    }

    offer.status = OfferStatus.PENDING;
    offer.overriddenAt = new Date();

    const updatedOffer = await this.offerRepository.save(offer);

    // Notify farmer about the override
    await this.notificationsService.create(
      offer.produce.farmerId,
      NotificationType.OFFER_UPDATED,
      'Auto-Generated Offer Modified',
      `A buyer has modified their auto-generated offer. New price: ${updatedOffer.pricePerUnit}, Quantity: ${updatedOffer.quantity}`,
      {
        offerId: updatedOffer.id,
        produceId: updatedOffer.produceId,
        buyerId: updatedOffer.buyerId,
      }
    );

    return updatedOffer;
  }

  async findExpiredAutoOffers(buyerId?: string, produceId?: string): Promise<Offer[]> {
    const query = this.offerRepository
      .createQueryBuilder('offer')
      .where('offer.status = :status', { status: OfferStatus.EXPIRED })
      .andWhere('offer.isAutoGenerated = :isAuto', { isAuto: true });

    if (buyerId) {
      query.andWhere('offer.buyerId = :buyerId', { buyerId });
    }

    if (produceId) {
      query.andWhere('offer.produceId = :produceId', { produceId });
    }

    return query.getMany();
  }

  async getAutoOfferQueueStatus(produceId: string) {
    const [activeOffers, queuedOffers] = await Promise.all([
      this.offerRepository.count({
        where: {
          produceId,
          status: OfferStatus.AUTO_GENERATED,
          isAutoGenerated: true,
        },
      }),
      this.offerRepository.find({
        where: {
          produceId,
          status: OfferStatus.QUEUED,
          isAutoGenerated: true,
        },
        relations: ['buyer'],
        order: {
          queuePosition: 'ASC',
        },
      }),
    ]);

    return {
      produceId,
      activeOffers,
      queuedOffers: queuedOffers.length,
      buyers: {
        queued: queuedOffers.map(offer => ({
          id: offer.buyerId,
          name: offer.buyer.name,
          queuePosition: offer.queuePosition,
        })),
      },
    };
  }

  async updateStatus(id: string, updateOfferDto: UpdateOfferDto): Promise<Offer> {
    const offer = await this.offerRepository.findOne({
      where: { id },
      relations: ['produce'],
    });

    if (!offer) {
      throw new NotFoundException(`Offer with ID ${id} not found`);
    }

    const oldStatus = offer.status;
    offer.status = updateOfferDto.status;

    if (updateOfferDto.message) {
      offer.message = updateOfferDto.message;
    }

    const updatedOffer = await this.offerRepository.save(offer);

    // Process queue if an auto-generated offer is accepted/rejected
    if (offer.isAutoGenerated && (oldStatus === OfferStatus.AUTO_GENERATED)) {
      await this.autoOfferManager.processQueue(offer.produceId);
    }

    return updatedOffer;
  }
} 
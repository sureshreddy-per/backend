import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, LessThan, In } from 'typeorm';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Offer } from '../entities/offer.entity';
import { AutoOfferRules } from '../entities/auto-offer-rules.entity';
import { OfferStatus } from '../enums/offer-status.enum';
import { NotificationsService } from '../../notifications/notifications.service';
import { NotificationType } from '../../notifications/entities/notification.entity';

interface CreateAutoOfferParams {
  buyerId: string;
  produceId: string;
  pricePerUnit: number;
  qualityGrade: string;
  qualityId: string;
}

interface OfferMetadata {
  qualityId?: string;
  qualityGrade?: string;
  autoGeneratedAt?: Date;
  priceHistory?: Array<{
    oldPrice: number;
    newPrice: number;
    updatedAt: Date;
  }>;
  lastPriceUpdate?: Date;
  expiryReason?: string;
  expiryMetadata?: any;
}

@Injectable()
export class AutoOfferManagerService {
  private readonly logger = new Logger(AutoOfferManagerService.name);

  constructor(
    @InjectRepository(Offer)
    private readonly offerRepository: Repository<Offer>,
    @InjectRepository(AutoOfferRules)
    private readonly rulesRepository: Repository<AutoOfferRules>,
    private readonly notificationsService: NotificationsService,
    private readonly eventEmitter: EventEmitter2,
  ) {}

  async handlePriceChange(buyerId: string, qualityGrade: string, oldPrice: number, newPrice: number): Promise<void> {
    const rules = await this.getRules();
    if (!rules.priceChangeExpiry) return;

    // Find all active auto-generated offers from this buyer
    const activeOffers = await this.offerRepository.find({
      where: {
        buyerId,
        status: OfferStatus.AUTO_GENERATED,
        isAutoGenerated: true,
      },
      relations: ['produce'],
    });

    const affectedOffers = activeOffers.filter(
      offer => offer.produce.qualityGrade === qualityGrade
    );

    const priceIncrease = newPrice > oldPrice;
    const priceChangePercent = Math.abs((newPrice - oldPrice) / oldPrice * 100);

    // Group offers by action needed
    const offersToUpdate: Offer[] = [];
    const offersToExpire: Offer[] = [];

    for (const offer of affectedOffers) {
      if (priceIncrease) {
        // For price increases, update all offers with the new price
        offersToUpdate.push(offer);
      } else {
        // For price decreases:
        // If the decrease is significant (>10%), expire the offer
        // Otherwise, update the price
        if (priceChangePercent > rules.significantPriceChangePercent) {
          offersToExpire.push(offer);
        } else {
          offersToUpdate.push(offer);
        }
      }
    }

    // Handle offers to update
    for (const offer of offersToUpdate) {
      const currentMetadata = offer.metadata || {};
      const priceHistory = currentMetadata.priceHistory || [];

      const updatedMetadata: OfferMetadata = {
        ...currentMetadata,
        priceHistory: [
          ...priceHistory,
          {
            oldPrice: offer.pricePerUnit,
            newPrice,
            updatedAt: new Date(),
          }
        ],
        lastPriceUpdate: new Date(),
      };

      const updatedOffer = await this.offerRepository.save({
        ...offer,
        pricePerUnit: newPrice,
        metadata: updatedMetadata,
      });

      // Notify farmer about price update
      await this.notificationsService.create(
        offer.produce.farmerId,
        NotificationType.OFFER_UPDATED,
        'Auto-Generated Offer Updated',
        `The price for an auto-generated offer has been updated from ${oldPrice} to ${newPrice}`,
        {
          offerId: offer.id,
          produceId: offer.produceId,
          oldPrice,
          newPrice,
        }
      );

      this.eventEmitter.emit('offer.price_updated', {
        offerId: updatedOffer.id,
        buyerId,
        produceId: updatedOffer.produceId,
        oldPrice,
        newPrice,
      });
    }

    // Handle offers to expire
    for (const offer of offersToExpire) {
      await this.expireOffer(offer, 'SIGNIFICANT_PRICE_DECREASE', {
        oldPrice,
        newPrice,
        priceChangePercent,
      });
    }

    // Notify farmers about expired offers
    if (offersToExpire.length > 0) {
      const groupedByFarmer = this.groupByFarmer(offersToExpire);
      for (const [farmerId, offers] of groupedByFarmer) {
        await this.notificationsService.create(
          farmerId,
          NotificationType.OFFER_EXPIRED,
          'Auto-Generated Offers Expired',
          `${offers.length} offers have expired due to significant price decrease. New price: ${newPrice} (${priceChangePercent.toFixed(1)}% decrease)`,
          {
            offerIds: offers.map(o => o.id),
            reason: 'SIGNIFICANT_PRICE_DECREASE',
            oldPrice,
            newPrice,
            priceChangePercent,
          }
        );
      }
    }
  }

  async processQueue(produceId: string): Promise<void> {
    const rules = await this.getRules();
    
    // Get current active offers
    const activeOffers = await this.offerRepository.count({
      where: {
        produceId,
        status: In([OfferStatus.AUTO_GENERATED, OfferStatus.PENDING]),
      },
    });

    if (activeOffers >= rules.maxActiveOffersPerProduce) {
      this.logger.log(`Maximum active offers (${rules.maxActiveOffersPerProduce}) reached for produce ${produceId}`);
      return;
    }

    // Get queued offers ordered by priority
    const queuedOffers = await this.getQueuedOffersByPriority(produceId, rules.priorityOrder);
    const slotsAvailable = rules.maxActiveOffersPerProduce - activeOffers;

    // Activate offers up to the limit
    for (let i = 0; i < Math.min(slotsAvailable, queuedOffers.length); i++) {
      const offer = queuedOffers[i];
      await this.activateOffer(offer);
    }
  }

  async expireOffer(offer: Offer, reason: string, metadata: any = {}): Promise<void> {
    const updatedMetadata: OfferMetadata = {
      ...offer.metadata,
      expiryReason: reason,
      expiryMetadata: metadata,
    };

    const updatedOffer = await this.offerRepository.save({
      ...offer,
      status: OfferStatus.EXPIRED,
      expiredAt: new Date(),
      metadata: updatedMetadata,
    });
    
    this.eventEmitter.emit('offer.expired', {
      offerId: updatedOffer.id,
      reason,
      metadata,
    });
  }

  private async activateOffer(offer: Offer): Promise<void> {
    const updatedOffer = await this.offerRepository.save({
      ...offer,
      status: OfferStatus.AUTO_GENERATED,
      metadata: {
        ...offer.metadata,
        activatedAt: new Date(),
      },
    });

    this.eventEmitter.emit('offer.activated', {
      offerId: updatedOffer.id,
      produceId: updatedOffer.produceId,
      buyerId: updatedOffer.buyerId,
    });
  }

  private async getQueuedOffersByPriority(produceId: string, priorityOrder: string[]): Promise<Offer[]> {
    const queryBuilder = this.offerRepository
      .createQueryBuilder('offer')
      .leftJoin('offer.buyer', 'buyer')
      .where('offer.produceId = :produceId', { produceId })
      .andWhere('offer.status = :status', { status: OfferStatus.QUEUED });

    // Add priority ordering
    priorityOrder.forEach((criterion, index) => {
      switch (criterion) {
        case 'rating':
          queryBuilder.addOrderBy('buyer.rating', 'DESC');
          break;
        case 'distance':
          queryBuilder.addOrderBy('buyer.distance', 'ASC');
          break;
        case 'historicalTransactions':
          queryBuilder.addOrderBy('buyer.completedTransactions', 'DESC');
          break;
      }
    });

    return queryBuilder.getMany();
  }

  private groupByFarmer(offers: Offer[]): Map<string, Offer[]> {
    return offers.reduce((map, offer) => {
      const farmerId = offer.produce.farmerId;
      if (!map.has(farmerId)) {
        map.set(farmerId, []);
      }
      map.get(farmerId)!.push(offer);
      return map;
    }, new Map<string, Offer[]>());
  }

  private async getRules(): Promise<AutoOfferRules> {
    const rules = await this.rulesRepository.findOne({
      order: { createdAt: 'DESC' },
    });
    return rules || new AutoOfferRules();
  }

  async cleanupExpiredOffers(): Promise<void> {
    const rules = await this.getRules();
    const expiryDate = new Date();
    expiryDate.setHours(expiryDate.getHours() - rules.defaultExpiryHours);

    const expiredOffers = await this.offerRepository.find({
      where: {
        status: OfferStatus.AUTO_GENERATED,
        isAutoGenerated: true,
        createdAt: LessThan(expiryDate),
      },
    });

    for (const offer of expiredOffers) {
      await this.expireOffer(offer, 'TIME_EXPIRED');
    }
  }

  async createAutoOffer(params: CreateAutoOfferParams): Promise<Offer> {
    // Check if an auto-offer already exists
    const existingOffer = await this.offerRepository.findOne({
      where: {
        buyerId: params.buyerId,
        produceId: params.produceId,
        status: OfferStatus.AUTO_GENERATED,
      },
    });

    if (existingOffer) {
      this.logger.log(`Auto-offer already exists for buyer ${params.buyerId} and produce ${params.produceId}`);
      return existingOffer;
    }

    // Create new auto-generated offer
    const offer = await this.offerRepository.save({
      buyerId: params.buyerId,
      produceId: params.produceId,
      pricePerUnit: params.pricePerUnit,
      status: OfferStatus.AUTO_GENERATED,
      isAutoGenerated: true,
      metadata: {
        qualityId: params.qualityId,
        qualityGrade: params.qualityGrade,
        autoGeneratedAt: new Date(),
      },
    });

    // Emit event for offer creation
    this.eventEmitter.emit('offer.auto_generated', {
      offerId: offer.id,
      buyerId: params.buyerId,
      produceId: params.produceId,
      pricePerUnit: params.pricePerUnit,
      qualityGrade: params.qualityGrade,
    });

    // Notify relevant parties
    await this.notificationsService.create(
      params.buyerId,
      NotificationType.OFFER_CREATED,
      'Auto-Generated Offer Created',
      `An offer has been automatically generated based on your price settings for grade ${params.qualityGrade}`,
      {
        offerId: offer.id,
        produceId: params.produceId,
        pricePerUnit: params.pricePerUnit,
      }
    );

    return offer;
  }
} 
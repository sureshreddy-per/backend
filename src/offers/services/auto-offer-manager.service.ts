import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, LessThan } from 'typeorm';
import { Offer } from '../entities/offer.entity';
import { OfferStatus } from '../enums/offer-status.enum';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class AutoOfferManagerService {
  constructor(
    @InjectRepository(Offer)
    private readonly offerRepository: Repository<Offer>,
    private readonly eventEmitter: EventEmitter2
  ) {}

  async findPendingAutoOffers() {
    return this.offerRepository.find({
      where: {
        status: OfferStatus.PENDING,
        metadata: {
          autoGeneratedAt: LessThan(new Date())
        }
      },
      relations: ['buyer', 'produce']
    });
  }

  async updatePrice(offerId: string, newPrice: number, reason?: string) {
    const offer = await this.offerRepository.findOne({
      where: { id: offerId },
      relations: ['buyer', 'produce']
    });

    if (!offer) {
      throw new Error('Offer not found');
    }

    const oldPrice = offer.pricePerUnit;
    const updatedMetadata = {
      ...offer.metadata,
      priceHistory: [
        ...(offer.metadata.priceHistory || []),
        {
          oldPrice,
          newPrice,
          timestamp: new Date(),
          reason
        }
      ],
      lastPriceUpdate: {
        oldPrice,
        newPrice,
        timestamp: new Date(),
        reason
      }
    };

    const updatedOffer = await this.offerRepository.save({
      ...offer,
      pricePerUnit: newPrice,
      metadata: updatedMetadata
    });

    this.eventEmitter.emit('offer.price.updated', {
      offerId: updatedOffer.id,
      buyerId: updatedOffer.buyerId,
      produceId: updatedOffer.produceId,
      pricePerUnit: updatedOffer.pricePerUnit
    });

    return updatedOffer;
  }

  async expireOffer(offerId: string, reason: string, metadata: any = {}) {
    const offer = await this.offerRepository.findOne({
      where: { id: offerId },
      relations: ['buyer', 'produce']
    });

    if (!offer) {
      throw new Error('Offer not found');
    }

    const updatedMetadata = {
      ...offer.metadata,
      expiryReason: reason,
      expiryMetadata: metadata
    };

    const updatedOffer = await this.offerRepository.save({
      ...offer,
      status: OfferStatus.EXPIRED,
      expiredAt: new Date(),
      metadata: updatedMetadata
    });

    this.eventEmitter.emit('offer.expired', {
      offerId: updatedOffer.id,
      reason,
      metadata
    });

    return updatedOffer;
  }

  async cleanupExpiredOffers() {
    const expiredOffers = await this.offerRepository.find({
      where: {
        status: OfferStatus.PENDING,
        expiredAt: LessThan(new Date())
      }
    });

    for (const offer of expiredOffers) {
      await this.expireOffer(
        offer.id,
        'Offer expired due to inactivity',
        { autoExpired: true }
      );
    }

    return expiredOffers.length;
  }
} 
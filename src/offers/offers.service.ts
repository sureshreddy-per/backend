import { Injectable, NotFoundException, BadRequestException, ConflictException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CreateOfferDto } from './dto/create-offer.dto';
import { Offer } from './entities/offer.entity';
import { OfferStatus } from './enums/offer-status.enum';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class OffersService {
  private readonly MAX_PRICE_HISTORY = 10;
  private readonly MIN_PRICE = 0.01;
  private readonly MAX_PRICE = 1000000; // 1 million
  private readonly MAX_ACTIVE_OFFERS_PER_BUYER = 50;

  constructor(
    @InjectRepository(Offer)
    private readonly offerRepository: Repository<Offer>,
    private eventEmitter: EventEmitter2,
  ) {}

  async create(buyerId: string, createOfferDto: CreateOfferDto): Promise<Offer> {
    // Validate buyer's active offers limit
    const activeOffersCount = await this.offerRepository.count({
      where: {
        buyerId,
        status: OfferStatus.PENDING,
      },
    });

    if (activeOffersCount >= this.MAX_ACTIVE_OFFERS_PER_BUYER) {
      throw new BadRequestException(
        `Maximum limit of ${this.MAX_ACTIVE_OFFERS_PER_BUYER} active offers per buyer reached`
      );
    }

    // Validate price
    if (createOfferDto.quotedPrice <= this.MIN_PRICE) {
      throw new BadRequestException(`Price must be greater than ${this.MIN_PRICE}`);
    }

    if (createOfferDto.quotedPrice > this.MAX_PRICE) {
      throw new BadRequestException(`Price cannot exceed ${this.MAX_PRICE}`);
    }

    // Check for existing offer
    const existingOffer = await this.offerRepository.findOne({
      where: {
        buyerId,
        produceId: createOfferDto.produceId,
        status: OfferStatus.PENDING,
      },
    });

    if (existingOffer) {
      throw new ConflictException('An active offer already exists for this produce');
    }

    try {
      const offer = this.offerRepository.create({
        buyerId,
        produceId: createOfferDto.produceId,
        pricePerUnit: createOfferDto.quotedPrice,
        status: OfferStatus.PENDING,
        metadata: {
          qualityGrade: createOfferDto.qualityGrade,
          autoGeneratedAt: null,
          priceHistory: [],
          lastPriceUpdate: null,
        },
      });

      const savedOffer = await this.offerRepository.save(offer);

      this.eventEmitter.emit('offer.created', {
        offerId: savedOffer.id,
        buyerId: savedOffer.buyerId,
        produceId: savedOffer.produceId,
        pricePerUnit: savedOffer.pricePerUnit,
      });

      return savedOffer;
    } catch (error) {
      throw new BadRequestException('Failed to create offer');
    }
  }

  async updatePrice(offerId: string, newPrice: number, overrideReason?: string): Promise<Offer> {
    if (!offerId) {
      throw new BadRequestException('Offer ID is required');
    }

    if (newPrice <= this.MIN_PRICE) {
      throw new BadRequestException(`Price must be greater than ${this.MIN_PRICE}`);
    }

    if (newPrice > this.MAX_PRICE) {
      throw new BadRequestException(`Price cannot exceed ${this.MAX_PRICE}`);
    }

    try {
      const offer = await this.offerRepository.findOne({ where: { id: offerId } });
      
      if (!offer) {
        throw new NotFoundException(`Offer with ID ${offerId} not found`);
      }

      if (offer.status !== OfferStatus.PENDING) {
        throw new BadRequestException('Cannot update price of non-pending offer');
      }

      const oldPrice = offer.pricePerUnit;
      offer.pricePerUnit = newPrice;

      // Update price history
      const priceUpdate = {
        oldPrice,
        newPrice,
        timestamp: new Date(),
        reason: overrideReason || 'Manual price update',
      };

      offer.metadata.priceHistory = [
        priceUpdate,
        ...(offer.metadata.priceHistory || []).slice(0, this.MAX_PRICE_HISTORY - 1),
      ];
      offer.metadata.lastPriceUpdate = priceUpdate;

      const updatedOffer = await this.offerRepository.save(offer);

      this.eventEmitter.emit('offer.price.updated', {
        offerId: updatedOffer.id,
        oldPrice,
        newPrice,
        reason: overrideReason,
      });

      return updatedOffer;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException('Failed to update offer price');
    }
  }

  async accept(offerId: string, farmerId: string): Promise<Offer> {
    if (!offerId) {
      throw new BadRequestException('Offer ID is required');
    }

    try {
      const offer = await this.offerRepository.findOne({
        where: { id: offerId },
        relations: ['produce'],
      });

      if (!offer) {
        throw new NotFoundException(`Offer with ID ${offerId} not found`);
      }

      if (offer.produce.farmerId !== farmerId) {
        throw new BadRequestException('Only the produce owner can accept this offer');
      }

      if (offer.status !== OfferStatus.PENDING) {
        throw new BadRequestException('Only pending offers can be accepted');
      }

      offer.status = OfferStatus.ACCEPTED;
      offer.acceptedAt = new Date();

      const acceptedOffer = await this.offerRepository.save(offer);

      this.eventEmitter.emit('offer.accepted', {
        offerId: acceptedOffer.id,
        buyerId: acceptedOffer.buyerId,
        produceId: acceptedOffer.produceId,
        farmerId,
      });

      return acceptedOffer;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException('Failed to accept offer');
    }
  }

  async reject(offerId: string, farmerId: string, reason: string): Promise<Offer> {
    if (!offerId) {
      throw new BadRequestException('Offer ID is required');
    }

    if (!reason) {
      throw new BadRequestException('Rejection reason is required');
    }

    try {
      const offer = await this.offerRepository.findOne({
        where: { id: offerId },
        relations: ['produce'],
      });

      if (!offer) {
        throw new NotFoundException(`Offer with ID ${offerId} not found`);
      }

      if (offer.produce.farmerId !== farmerId) {
        throw new BadRequestException('Only the produce owner can reject this offer');
      }

      if (offer.status !== OfferStatus.PENDING) {
        throw new BadRequestException('Only pending offers can be rejected');
      }

      offer.status = OfferStatus.REJECTED;
      offer.rejectedAt = new Date();
      offer.rejectionReason = reason;

      const rejectedOffer = await this.offerRepository.save(offer);

      this.eventEmitter.emit('offer.rejected', {
        offerId: rejectedOffer.id,
        buyerId: rejectedOffer.buyerId,
        produceId: rejectedOffer.produceId,
        farmerId,
        reason,
      });

      return rejectedOffer;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException('Failed to reject offer');
    }
  }

  async cancel(offerId: string, buyerId: string, reason: string): Promise<Offer> {
    if (!offerId) {
      throw new BadRequestException('Offer ID is required');
    }

    if (!reason) {
      throw new BadRequestException('Cancellation reason is required');
    }

    try {
      const offer = await this.offerRepository.findOne({ where: { id: offerId } });

      if (!offer) {
        throw new NotFoundException(`Offer with ID ${offerId} not found`);
      }

      if (offer.buyerId !== buyerId) {
        throw new BadRequestException('Only the offer creator can cancel this offer');
      }

      if (offer.status !== OfferStatus.PENDING) {
        throw new BadRequestException('Only pending offers can be cancelled');
      }

      offer.status = OfferStatus.CANCELLED;
      offer.cancelledAt = new Date();
      offer.cancellationReason = reason;

      const cancelledOffer = await this.offerRepository.save(offer);

      this.eventEmitter.emit('offer.cancelled', {
        offerId: cancelledOffer.id,
        buyerId,
        produceId: cancelledOffer.produceId,
        reason,
      });

      return cancelledOffer;
    } catch (error) {
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException('Failed to cancel offer');
    }
  }

  async findByBuyer(buyerId: string, page = 1, limit = 10): Promise<{ items: Offer[]; meta: any }> {
    if (page < 1) {
      throw new BadRequestException('Page number must be greater than 0');
    }

    if (limit < 1 || limit > 50) {
      throw new BadRequestException('Limit must be between 1 and 50');
    }

    try {
      const [items, total] = await this.offerRepository.findAndCount({
        where: { buyerId },
        relations: ['produce', 'produce.farmer'],
        skip: (page - 1) * limit,
        take: limit,
        order: {
          createdAt: 'DESC',
        },
      });

      const totalPages = Math.ceil(total / limit);

      return {
        items,
        meta: {
          total,
          page,
          limit,
          totalPages,
          hasNext: page < totalPages,
          hasPrevious: page > 1,
        },
      };
    } catch (error) {
      throw new BadRequestException('Failed to fetch offers');
    }
  }
} 